#!/usr/bin/env nodejs

var cp = require('child_process');
var fs = require('fs');
var util = require('util');
var url = require('url');
var http = require('http');

if (process.getuid() != 0) {
    console.log("[ERROR] Please run this program as 'root'!");
    process.exit(1);
}

if (process.argv.length == 2) {
    process.exit(0);
}

var argv = process.argv;
var cmd = {
    cmd: undefined,
    args: [],
    options: []
};
var isArgsToken = false;
for (var i = 2; i < argv.length; ++ i) {
    if (argv[i] === 'dist-upgrade') {
        cmd.cmd = 'dist-upgrade';
    }
    else if (argv[i] === 'install') {
        cmd.cmd = 'install';
        isArgsToken = true;
    }
    else if (argv[i][0] === '-') {
        cmd.options.push(argv[i]);
        isArgsToken = false; 
    }
    else {
        if (isArgsToken) { 
           cmd.args.push(argv[i]);
        }
        else {
            console.log("[ERROR] wrong command arguments");
            process.exit(1);
        }
    }
}
//if (cmd.cmd == 'install' && cmd.args.length == 0) {
//    console.log("[ERROR] wrong 'install' command arguments");
//    process.exit(1);
//}
console.log("[DEBUG] " + JSON.stringify(cmd));
//process.exit(0);
    

var dl = {
    destDir: '/var/cache/apt/archives',
    sizeTotal: 0,
    sizeComplete: 0,
    sizeThread: 100000,
    nThreads: 0,
    nThreadsMax: 64,
    pkgs: [],
    nPkgs: 0,
    iPkgNext: 0
};

aptgetPrinturis(cmd);

function aptgetPrinturis (cmd) {
    var pkgs = []; 

    var aptargs = [];
    if (cmd.cmd === 'install') {
        aptargs = ['install'];
        aptargs = aptargs.concat(cmd.args).concat(cmd.options);
    }
    else if (cmd.cmd === 'dist-upgrade') {
        aptargs = ['dist-upgrade'];
    }
    else {
        invokeAptget();
        process.exit(0);
    }
    aptargs.push('-qq', '--print-uris', '-f');
    //console.log("[DEBUG] 'apt-get %s'", aptargs.join(' '));

    var procAptgetPrinturis = cp.spawn('apt-get', aptargs, {stdio: [process.stdin, 'pipe', process.stderr]});
    var stdout = '';

    procAptgetPrinturis.stdout.on('data', function (data) {
        stdout += data.toString();
    });

    procAptgetPrinturis.on('exit', function (code, signal) {
        if (!signal) {
            if (code) {
                console.log('[ERROR] exit: ' + code);
                return code;
            }
            else {
                stdout.split('\n').forEach(function (e) {
                    if (!e) return;
                    var token = e.split(' '); 
                    //console.log("[DEBUG] token=" + token);
                    pkgs.push({
                        uri:  token[0].slice(1, -1),
                        file: token[1],
                        size: parseInt(token[2]),
                        md5:  token[3].split(':')[1]
                    }); 
                    dl.sizeTotal += parseInt(token[2]);
                });
                dl.nPkgs = pkgs.length;
                dl.pkgs = pkgs;
                //console.log("[DEBUG] " + pkgs.length);
                if (dl.nPkgs) {
                    removeOldFiles(dl);
                    download(dl);
                }
                else {
                    invokeAptget();
                }
            }
        }
    });
}

function removeOldFiles (dl) {
    console.log("[INFO] Removing the follwing package files:");
    dl.pkgs.forEach(function (e) {
        var filePath = dl.destDir + e.file; 
        if (fs.existsSync(filePath)) {
            fs.unlink(filePath, function (err) {
                if (err) console.log("[ERROR] " + err);
            });
            console.log("[INFO]     " + e.file);
        }
    });
}


function download (dl) {
    console.log("[INFO] Completed download: %dBytes (%d\%)", dl.sizeComplete, parseInt(dl.sizeComplete * 100 / dl.sizeTotal));
    // invoke as many download threads as 'nThreadMax'
    for (; dl.nThreads < dl.nThreadsMax && dl.iPkgNext < dl.nPkgs; ++ dl.iPkgNext) {
        downloadOnePkg(dl, dl.iPkgNext, false);
    }
    console.log("[DEBUG] 'dl.nThreads = %d, dl.iPkgNext = %d", dl.nThreads, dl.iPkgNext);

    // wait 500ms for some empty thread slots
    if (dl.iPkgNext < dl.nPkgs || dl.nThreads) {
        setTimeout(download, 1000, dl);
    }
    else { // all downloads succeed, run the apt-get command
        console.log("[INFO] All downloaded packages are verified successfully! Now install it!");
        invokeAptget();
    }
}
 

function downloadOnePkg (dl, i, isRedownload) {
    var pkg = dl.pkgs[i];
    var nThreads = parseInt(pkg.size / dl.sizeThread) + 1;
    if (nThreads + dl.nThreads > dl.nThreadsMax) {
        nThreads = dl.nThreadsMax - dl.nThreads;
    }
    if (!isRedownload) {
        dl.nThreads += nThreads;
    }

    downloadOnePkgByAxel(nThreads);
    //downloadOnePkgByNode(nThreads);

    function downloadOnePkgByNode(nThreads) {
            multiThreadedHttpGet(
                pkg.uri, 
                pkg.file, 
                nThreads, 
                function (destFile, size, nThreadsRemained) {
                    dl.nThreads -= (nThreads - nThreadsRemained);
                    console.log("[INFO] '%s': %d%", destFile, parseInt(size * 100 / pkg.size));
                });
    }

    // Downloand function using 'axel'
    function downloadOnePkgByAxel(nThreads) {
        var cmdLine = ['-o', pkg.file, '-n', nThreads.toString(), pkg.uri, '-a'];
        console.log("[INFO] Downloading package... 'axel %s'", cmdLine.join(' '));
        var procDownload = cp.spawn(
            'axel', 
            cmdLine, 
            {cwd: dl.destDir, stdio: 'inherit'});
        //var logLine = '';
        //procDownload.stdout.on('data', function (data) {
        //    var s = data.toString();
        //    var n = s.lastIndexOf('\n');
        //    // Print what prior to a new-line
        //    if (n != -1) {
        //        logLine += s.slice(0, n);
        //        console.log(logLine);
        //        logLine = s.slice(n + 1); // '' if s[-1] === '\n'
        //    }
        //    else {
        //        logLine += s;
        //    }
        //});
        procDownload.on('exit', function (code, signal) {
            if (!signal) { // program exits normally
                if (code) { // w/ error, re-download it
                    download(dl, i, true);
                }
                else { // w/o error
                    // check the md5sum
                    var md5File = pkg.md5 + ' *' + pkg.file;
                    var procVerifyFiles = cp.spawn(
                        'md5sum', 
                        ['-c', '--status'], 
                        {cwd: dl.destDir, stdio: ['pipe', 'ignore', process.stderr]});
                    procVerifyFiles.stdin.write(md5File);
                    procVerifyFiles.stdin.end();
                    procVerifyFiles.on('exit', function (code, signal) {
                        if (!signal) { // program exits normally
                            if (code) { // w/ error, re-download it
                                console.log("[ERROR] " + "md5sum verification failed for '" + md5File + "'");
                                //remove the bad one
                                var filePath = dl.destDir + pkg.file; 
                                if (fs.existSync(filePath)) {
                                    fs.unlink(filePath, function (err) {
                                        if (err) console.log("[ERROR] " + err);
                                    });
                                }
                                downloadOnePkg(dl, i, true);
                            }
                            else { // md5sum succeeded
                                console.log("[INFO] " + "md5sum verification succeeded for '" + pkg.file + "'");
                                dl.nThreads -= nThreads; //release thread slots
                                dl.sizeComplete += pkg.size;
                                //console.log("[DEBUG] 'nThreadsTotal -= nThreads;' nThreadsTotal = %d, i = %d", nThreadsTotal ,i);
                            }
                        }
                    });
                }
            }
        });
    }
}

function invokeAptget () {
    console.log("[DEBUG] command 'apt-get " + process.argv.slice(2) + "'");
    var procAptget = cp.spawn('apt-get', process.argv.slice(2), {stdio: 'inherit'});
};


function multiThreadedHttpGet(srcUrl, destPath, nThreads, callback) {
    //console.log("[DEBUG] srcUrl: %s, destPath: %s, nThreads: %d", srcUrl, destPath, nThreads);
    var url = require('url');
    var urlObj = url.parse(srcUrl);

    var options = {
          hostname: urlObj.hostname,
          port:urlObj.port, 
          path: urlObj.path,
          method: 'HEAD'
    };

    http.request(options, function(res) {
        var i;
        //console.log('STATUS: ' + res.statusCode);
        //console.log('HEADERS: ' + util.inspect(res.headers, {colors: true}));
        if (res.statusCode != 200) {
            console.log("[ERROR] HTTP 'HEAD' error code: " + res.statusCode);
            exit(1);
        }
        if (res.headers['accept-ranges'] !== 'bytes') {
            console.log("[ERROR] HTTP partial 'GET' is not supported! " + util.inspect(res.headers, {colors: true}));
            exit(1);
        }
        var sizeFile = res.headers['content-length'];
        options.method = 'GET';

        var threads = [];
        for (i = 0; i < nThreads; i ++) {
            threads.push({bufs: [], size: 0, finised: false});
        }
        //console.log(threads);

        var start = 0;
        var step = sizeFile / nThreads;
        var last = sizeFile % nThreads;
        if (last) {
            step = parseInt(step) + 1;
        }
        i = 0;
        //console.log("fuck: %d, %d, %d", start, step, last);
        while (start + step <= sizeFile) {
            getPartialFile(i, start, start + step - 1);
            start += step;
            i ++;
        }
        if (last) {
            getPartialFile(i, start, sizeFile - 1);
        }

        (function timerCallback () {
            var size = 0;
            if (threads.every(function (e) {return e.finished;})) { // GOT all
                var bufs = threads.map(function (e) {
                    //console.log("[DEBUG] e.bufs.length: %d, e.size: %d", e.bufs.length, e.size);
                    var buf = Buffer.concat(e.bufs, e.size);
                    size += e.size;
                    return buf;
                });
                //console.log("[DEBUG] bufs.length: %d, size: %d", bufs.length, size);
                var bufFile = Buffer.concat(bufs, size);
                var fd = fs.createWriteStream(destPath);
                fd.write(bufFile);
                fd.end();
            }
            else {
                threads.forEach(function (e) {
                    size += e.size;
                });
                //console.log("threads size: %d", size);

                callback(destPath, size, nThreads);

                setTimeout(timerCallback, 3000);
            }
        })();

        function getPartialFile (i, start, end) {
            var req = http.request(options, function(res) {
                if (res.statusCode != 206) {
                    console.log("[ERROR] HTTP partial 'GET' failed! " + util.inspect(res.headers, {colors: true}));
                    exit(1);
                }
        console.log('HEADERS: ' + util.inspect(res.headers, {colors: true}));
                res.on('data', function (chunk) {
                    var t = threads[i];
                    t.bufs.push(chunk);
                    t.size += chunk.length; 
                    //console.log("chunk: size: %d", t.size);

                }).on('end', function() {
                    var t = threads[i];
                    t.finished = true;
                    nThreads --;
                    //console.log(t);
                });

            });
            req.setHeader('range', 'bytes=' + start + '-' + end);
            req.end();
        }
    }).on('error', function(e) {
        console.log("[ERROR] Problem with http 'HEAD' request: " + e.message);
    }).end();
    
}
